{   
    "PyTorch Imports": {
        "prefix": "pytorch:imports",
        "description": "Common pytorch imports",
        "body":[
            "import torch",
            "import torch.nn as nn",
            "import torch.nn.functional as F",
            "import torch.optim as optim"
        ]
    },
    "Check Device": {
        "prefix": "pytorch:device",
        "description": "Check the available device",
        "body":[
            "device = torch.device('cuda:0' if torch.cuda.is_available() else 'cpu')"
        ]
    },
    "PyTorch Module": {
        "prefix": "pytorch:module",
        "description": "Creates a custom class template which inherits from torch.nn.Module",
        "body": [
            "class ${1:MyModule}(nn.Module):",            
            "\t\"\"\"Some Information about ${1:MyModule}\"\"\"",
            "\tdef __init__(self):",
            "\t\tsuper(${1:MyModule}, self)__init__()",
            "",
            "\tdef forward(self, x):",
            "",
            "\t\treturn x"
        ]
    },
    "PyTorch Autograd Function": {
        "prefix": "pytorch:function",
        "description": "Creates a custom autograd function template which inherits from torch.autograd.Function",
        "body": [
            "class ${1:MyFunction}(torch.autograd.Function):",            
            "\t\"\"\"Some Information about ${1:MyFunction}\"\"\"",
            "\t@staticmethod",
            "\tdef forward(ctx, input):",
            "",
            "\t\treturn input",
            "",
            "\t@staticmethod",
            "\tdef backward(ctx, grad_output)",
            "\t\tgrad_input = grad_output.clone()",
            "",
            "\t\treturn grad_input"
        ]
    },
    "Train Loop": {
        "prefix": "pytorch:train",
        "description": "Creates a simple training loop",
        "body":[
            "# loop over the dataset multiple times",
            "for epoch in range(${1:5}):",
            "\trunning_loss = 0.0",
            "\tfor i, data in enumerate(${2:trainloader}, 0):",
            "\t\tinputs, labels = data",
            "",
            "\t\t# zero the parameter gradients",
            "\t\t${3:optimizer}.zero_grad()",
            "",
            "\t\t# forward + backward + optimize",
            "\t\toutputs = ${4:net}(inputs)",
            "\t\tloss = ${5:criterion}(outputs, labels)",
            "\t\tloss.backward()",
            "\t\t${3:optimizer}.step()",
            "",
            "\t\trunning_loss += loss.item()",
            "\t\tif i % ${6:2000} == ${6:2000} -1    # print every 2000 mini-batches",
            "\t\t\tprint('[%d, %5d] loss: %.3f' % (epoch + 1, i + 1, running_loss / ${6:2000}))",
            "\t\t\trunning_loss = 0.0",
            "",
            "print('Finished Training')"
        ]
    },
    "Freeze Layers": {
        "prefix": "pytorch:freeze",
        "desription": "Freeze all layers of the network",
        "body": [
            "for params in ${1:model}.parameters():",
            "\tparams.require_grad = False"
        ]
    },
    "Unfreeze Layers":{
        "prefix": "pytorch:unfreeze",
        "desription": "Unfreeze all layers of the network",
        "body": [
            "for params in ${1:model}.parameters():",
            "\tparams.require_grad = True"
        ]
    },
    "Resnet Basic Block":{
        "prefix": "pytorch:layer:resblock",
        "description": "Creates a Resnet basic block",
        "body": [
            "import torch.nn as nn",
            "",
            "class BasicBlock(nn.Module):",
            "\t# see https://pytorch.org/docs/0.4.0/_modules/torchvision/models/resnet.html",
            "\tdef __init__(self, inplanes, planes, stride=1):",
            "\t\tsuper(BasicBlock, self).__init__()",
            "\t\tself.conv1 = nn.Conv2d(inplanes, planes, kernel_size=3, stride=stride, padding=1, bias=False)",
            "\t\tself.bn1 = nn.BatchNorm2d(planes)",
            "\t\tself.relu = nn.ReLU(inplace=True)",
            "\t\tself.conv2 = nn.Conv2d(planes, planes, kernel_size=3, padding=1, bias=False)",
            "\t\tself.bn2 = nn.BatchNorm2d(planes)",
            "",
            "\tdef forward(self, x):",
            "\t\tresidual = x",
            "\t\tout = self.conv1(x)",
            "\t\tout = self.bn1(out)",
            "\t\tout = self.relu(out)",
            "\t\tout = self.conv2(out)",
            "\t\tout = self.bn2(out)",
            "\t\tout += residual",
            "\t\tout = self.relu(out)",
            "\t\treturn out"
        ]
    },
    "Resnet Bottleneck Block":{
        "prefix": "pytorch:layer:resbottleneck",
        "description": "Creates a Resnet bottleneck block",
        "body": [
            "import torch.nn as nn",
            "",
            "class Bottleneck(nn.Module):",
            "\t# see https://pytorch.org/docs/0.4.0/_modules/torchvision/models/resnet.html ",
            "\tdef __init__(self, inplanes, planes, stride=1, downsample=None):",
            "\t\tsuper(Bottleneck, self).__init__()",
            "\t\tself.conv1 = nn.Conv2d(inplanes, planes, kernel_size=1, stride=stride, bias=False)",
            "\t\tself.bn1 = nn.BatchNorm2d(planes)",
            "\t\tself.conv2 = nn.Conv2d(planes, planes, kernel_size=3, stride=1, padding=1, bias=False)",
            "\t\tself.bn2 = nn.BatchNorm2d(planes)",
            "\t\tself.conv3 = nn.Conv2d(planes, planes * 4, kernel_size=1, bias=False)",
            "\t\tself.bn3 = nn.BatchNorm2d(planes * 4)",
            "\t\tself.relu = nn.ReLU(inplace=True)",
            "",
            "\tdef forward(self, x):",
            "\t\tresidual = x",
            "\t\tout = self.conv1(x)",
            "\t\tout = self.bn1(out)",
            "\t\tout = self.relu(out)",
            "\t\tout = self.conv2(out)",
            "\t\tout = self.bn2(out)",
            "\t\tout = self.relu(out)",
            "\t\tout = self.conv3(out)",
            "\t\tout = self.bn3(out)",
            "\t\tout += residual",
            "\t\tout = self.relu(out)",
            "\t\treturn out"
        ]
    },
    "Train Image Classifier on CIFAR10": {
        "prefix": "pytorch:example:cifar10",
        "description": "Creates an image classifier on CIFAR10",
        "body":[
            "# image classifier example taken from:",
            "# https://pytorch.org/tutorials/beginner/blitz/cifar10_tutorial.html#sphx-glr-beginner-blitz-cifar10-tutorial-pyy",
            "",
            "import torch",
            "import torch.nn as nn",
            "import torch.nn.functional as F",
            "import torch.optim as optim",
            "import torchvision",
            "import torchvision.transforms as transforms",
            "",
            "device = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")",
            "",
            "transform = transforms.Compose(",
            "\t[transforms.ToTensor(),",
            "\ttransforms.Normalize((0.4914, 0.4822, 0.4465), (0.2023, 0.1994, 0.2010))])",
            "",
            "trainset = torchvision.datasets.CIFAR10(root='./data', train=True, download=True, transform=transform)",
            "trainloader = torch.utils.data.DataLoader(trainset, batch_size=4, shuffle=True, num_workers=2)",
            "",
            "testset = torchvision.datasets.CIFAR10(root='./data', train=False, download=True, transform=transform)",
            "testloader = torch.utils.data.DataLoader(testset, batch_size=4, shuffle=False, num_workers=2)",
            "",
            "classes = ('plane', 'car', 'bird', 'cat', 'deer', 'dog', 'frog', 'horse', 'ship', 'truck')",
            "",
            "class Net(nn.Module):",            
            "\t\"\"\"CIFAR10 Image Classifier Network\"\"\"",
            "\tdef __init__(self):",
            "\t\tsuper(Net, self)__init__()",
            "\t\tself.conv1 = nn.Conv2d(3, 6, 5)",
            "\t\tself.pool = nn.MaxPool2d(2, 2)",
            "\t\tself.conv2 = nn.Conv2d(6, 16, 5)",
            "\t\tself.fc1 = nn.Linear(16 * 5 * 5, 120)",
            "\t\tself.fc2 = nn.Linear(120, 84)",
            "\t\tself.fc3 = nn.Linear(84, 10)",
            "",
            "\tdef forward(self, x):",
            "\t\tx = self.pool(F.relu(self.conv1(x)))",
            "\t\tx = self.pool(F.relu(self.conv2(x)))",
            "\t\tx = x.view(-1, 16 * 5 * 5)",
            "\t\tx = F.relu(self.fc1(x))",
            "\t\tx = F.relu(self.fc2(x))",
            "\t\tx = self.fc3(x)",
            "\t\treturn x",
            "",
            "",
            "net = Net()",
            "net.to(device)",
            "",
            "criterion = nn.CrossEntropyLoss()",
            "optimizer = optim.SGD(net.parameters(), lr=0.001, momentum=0.9)",
            "",
            "# loop over the dataset multiple times",
            "for epoch in range(3):",
            "\trunning_loss = 0.0",
            "\tfor i, data in enumerate(trainloader, 0):",
            "\t\tinputs, labels = data",
            "\t\tinputs, labels = inputs.to(device), labels.to(device)",
            "",
            "\t\t# zero the parameter gradients",
            "\t\t${3:optimizer}.zero_grad()",
            "",
            "\t\t# forward + backward + optimize",
            "\t\toutputs = net(inputs)",
            "\t\tloss = criterion(outputs, labels)",
            "\t\tloss.backward()",
            "\t\toptimizer.step()",
            "",
            "\t\trunning_loss += loss.item()",
            "\t\tif i % 2000 == 2000 -1    # print every 2000 mini-batches",
            "\t\t\tprint('[%d, %5d] loss: %.3f' % (epoch + 1, i + 1, running_loss / 2000))",
            "\t\t\trunning_loss = 0.0",
            "",
            "print('Finished Training')",
            "",
            "# evaluate classifier performance on test set",
            "correct = 0",
            "total = 0",
            "net.eval()",
            "with torch.no_grad():",
            "\tfor data in testloader:",
            "\t\timages, labels = data",
            "\t\timages, labels = images.to(device), labels.to(device)",
            "\t\toutputs = net(images)",
            "\t\t_, predicted = torch.max(outputs.data, 1)",
            "\t\ttotal += labels.size(0)",
            "\t\tcorrect += (predicted == labels).sum().item()",
            "",
            "print('Accuracy of the network on the 10000 test images: %d %%' % (100 * correct / total))"
        ]
    },
    "Train Image Classifier on MNIST": {
        "prefix": "pytorch:example:mnist",
        "description": "Creates an image classifier on CIFAR10",
        "body":[
            "# image classifier example taken from:",
            "# https://pytorch.org/tutorials/beginner/blitz/cifar10_tutorial.html#sphx-glr-beginner-blitz-cifar10-tutorial-pyy",
            "",
            "import torch",
            "import torch.nn as nn",
            "import torch.nn.functional as F",
            "import torch.optim as optim",
            "import torchvision",
            "import torchvision.transforms as transforms",
            "",
            "device = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")",
            "",
            "transform = transforms.Compose(",
            "\t[transforms.ToTensor(),",
            "\ttransforms.Normalize((0.1307,), (0.3081,))])",
            "",
            "trainset = torchvision.datasets.MNIST(root='./data', train=True, download=True, transform=transform)",
            "trainloader = torch.utils.data.DataLoader(trainset, batch_size=4, shuffle=True, num_workers=2)",
            "",
            "testset = torchvision.datasets.MNIST(root='./data', train=False, download=True, transform=transform)",
            "testloader = torch.utils.data.DataLoader(testset, batch_size=4, shuffle=False, num_workers=2)",
            "",
            "classes = ('plane', 'car', 'bird', 'cat', 'deer', 'dog', 'frog', 'horse', 'ship', 'truck')",
            "",
            "class Net(nn.Module):",            
            "\t\"\"\"MNIST Image Classifier Network\"\"\"",
            "\tdef __init__(self):",
            "\t\tsuper(Net, self)__init__()",
            "\t\tself.conv1 = nn.Conv2d(1, 10, kernel_size=5)",
            "\t\tself.conv2 = nn.Conv2d(10, 20, kernel_size=5)",
            "\t\tself.conv2_drop = nn.Dropout2d()",
            "\t\tself.fc1 = nn.Linear(320, 50)",
            "\t\tself.fc2 = nn.Linear(50, 10)",
            "",
            "\tdef forward(self, x):",
            "\t\tx = F.relu(F.max_pool2d(self.conv1(x), 2))",
            "\t\tx = F.relu(F.max_pool2d(self.conv2_drop(self.conv2(x)), 2))",
            "\t\tx = x.view(-1, 320)",
            "\t\tx = F.relu(self.fc1(x))",
            "\t\tx = F.dropout(x, training=self.training)",
            "\t\tx = self.fc2(x)",
            "\t\treturn F.log_softmax(x, dim=1)",
            "",
            "",
            "net = Net()",
            "net.to(device)",
            "",
            "criterion = nn.NLLLoss()",
            "optimizer = optim.SGD(net.parameters(), lr=0.001, momentum=0.9)",
            "",
            "# loop over the dataset multiple times",
            "for epoch in range(3):",
            "\trunning_loss = 0.0",
            "\tfor i, data in enumerate(trainloader, 0):",
            "\t\tinputs, labels = data",
            "\t\tinputs, labels = inputs.to(device), labels.to(device)",
            "",
            "\t\t# zero the parameter gradients",
            "\t\toptimizer.zero_grad()",
            "",
            "\t\t# forward + backward + optimize",
            "\t\toutputs = net(inputs)",
            "\t\tloss = criterion(outputs, labels)",
            "\t\tloss.backward()",
            "\t\toptimizer.step()",
            "",
            "\t\trunning_loss += loss.item()",
            "\t\tif i % 2000 == 2000 -1    # print every 2000 mini-batches",
            "\t\t\tprint('[%d, %5d] loss: %.3f' % (epoch + 1, i + 1, running_loss / 2000))",
            "\t\t\trunning_loss = 0.0",
            "",
            "print('Finished Training')",
            "",
            "# evaluate classifier performance on test set",
            "correct = 0",
            "total = 0",
            "net.eval()",
            "with torch.no_grad():",
            "\tfor data in testloader:",
            "\t\timages, labels = data",
            "\t\timages, labels = images.to(device), labels.to(device)",
            "\t\toutputs = net(images)",
            "\t\t_, predicted = torch.max(outputs.data, 1)",
            "\t\ttotal += labels.size(0)",
            "\t\tcorrect += (predicted == labels).sum().item()",
            "",
            "print('Accuracy of the network on the 10000 test images: %d %%' % (100 * correct / total))"
        ]
    }
}